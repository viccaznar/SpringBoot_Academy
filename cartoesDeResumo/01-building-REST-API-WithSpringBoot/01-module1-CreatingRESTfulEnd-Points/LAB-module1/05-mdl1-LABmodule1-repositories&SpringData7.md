7: Configurar o Banco de Dados  
Nossos testes esperam que a API encontre e retorne um CashCard com id 99. Porém, acabamos de remover os dados hard-coded do CashCard no Controller e substituí-los por uma chamada a `cashCardRepository.findById`.

Agora nossa aplicação está falhando, reclamando que falta uma tabela no banco de dados chamada `CASH_CARD`:

org.h2.jdbc.JdbcSQLSyntaxErrorException: Table "CASH_CARD" not found (this database is empty);


Precisamos ajudar o Spring Data a configurar o banco e carregar alguns dados de exemplo, como nosso amigo CashCard 99.

O Spring Data e o H2 conseguem criar e popular automaticamente o banco em memória necessário para nossos testes. Fornecemos dois arquivos para isso, mas você precisará editá-los: `schema.sql` e `data.sql`.

Observação: Fornecer `schema.sql` e `data.sql` é uma das várias maneiras que o Spring oferece para inicializar facilmente um banco de dados. Para saber mais, consulte a documentação do Spring Framework.

---

## Editar o schema.sql  
Conforme mencionado, o Spring Data configura automaticamente um banco para testes se encontrarmos o arquivo certo no local correto. E já temos! É o `src/main/resources/schema.sql`. Mas hoje ele está desabilitado.

Abra `src/main/resources/schema.sql` e remova o comentário em bloco `/* ... */`, deixando:

```sql
CREATE TABLE cash_card
(
   ID     BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
   AMOUNT NUMBER NOT NULL DEFAULT 0
);
Entendendo o schema.sql
Um schema de banco de dados é a “planta” de como os dados são armazenados em um banco. Não vamos detalhar schemas aqui, mas o nosso reflete o objeto CashCard que conhecemos: com um campo id e um campo amount.

Rerun dos testes
Observação: se a saída dos testes estiver muito verbosa, reverta a alteração em build.gradle feita anteriormente.

Agora os testes não caem mais com 500 INTERNAL_SERVER_ERROR, mas recebem:

CashCardApplicationTests > shouldReturnACashCardWhenDataIsSaved() FAILED
 org.opentest4j.AssertionFailedError:
 expected: 200 OK
  but was: 404 NOT_FOUND
Tradução: nosso repositório não encontrou o CashCard de id 99. Por quê?

Apesar de termos ajudado o Spring Data a criar o banco de testes ao descomentar schema.sql, o banco ainda está vazio.

Carregar dados de teste via data.sql
Além de criar o banco, o Spring Data pode popular tabelas com dados de teste que usamos nos nossos testes. Similar ao schema.sql, fornecemos src/test/resources/data.sql, mas seu conteúdo também está comentado em bloco.

Abra src/test/resources/data.sql e remova o comentário em bloco, deixando:

sql
INSERT INTO CASH_CARD(ID, AMOUNT) VALUES (99, 123.45);
Essa instrução SQL insere uma linha na tabela CASH_CARD com ID=99 e AMOUNT=123.45, valores que nossos testes esperam.

Rerun dos testes
Eles passam! Oba!

bash
[~/exercises] $ ./gradlew test
...
BUILD SUCCESSFUL in 7s
Sucesso! Agora estamos usando dados reais na nossa API.

Momento de aprendizado: recursos main vs test
Você percebeu que src/main/resources/schema.sql e src/test/resources/data.sql estão em pastas de recursos diferentes? Consegue adivinhar por quê?

Lembre-se: nosso CashCard com ID 99 e Amount 123.45 é falso, criado só para os testes. Não queremos que o sistema “real” ou de produção carregue esse CashCard 99 — o que aconteceria com o CashCard 99 verdadeiro?

O Spring oferece um recurso poderoso: permite separar recursos usados apenas em testes dos recursos principais quando necessário. Nosso cenário é um exemplo comum: o schema do banco é sempre o mesmo, mas os dados variam!

Obrigado novamente, Spring!